We used Flask to design the entire website. Most of the configuration, setup, and libraries for the website were borrowed from CS50Finance. 

The layout of our website was inspired by Bootstrap’s examples on website design, namely their design at https://getbootstrap.com/docs/4.0/examples/cover/. From this general framework, we opted to make a minimalist but aesthetically pleasing site that only used two fonts, Trebuchet MS and Source Code Pro for simplicity. The background was inspired by a gradient shifting CSS background that we found at this website: https://blog.prototypr.io/5-css-animated-backgrounds-to-inspire-your-next-project-97fdb692e852. This background changes color gradually from red, to blue, to pink, to white and is supposed to give the feeling of emotions coming and passing and has the same effect as a mood ring would in representing feelings. At the top, the nav bar features links that are floating on the page so that they exist with the changing background colors. The navlinks also reveal underlines once they are hovered over. 

The login page features a box with rounded corners containing the login form. The rounded corners make for a more soft and modern feel that really complements the aesthetic of the site. The functionality of this page and the registration page are similar to CS50 where the user submits a form where the username is checked and the password is run through a hash and also checked. The login page also sets up the other pages which most required the user to be logged in in order to view them. The logout button simply clears the users session and prompts them to login again. 

After logging in, the user is taken to the main page of the website which features a textarea box where the user can begin journaling. This textarea features transparent backgrounds so that they capture the changing colors of the background and almost look like thin sheets of paper. The timer at the bottom is programmed using JavaScript so that it will only start once the user has typed a character into the journal entry textarea. Additionally, once the timer runs out, the form will automatically submit. We believe that the automatic start to the timer and automatic submission make for very seamless user interaction with this page. For the clear button, we attached a JavaScript script to the html code that upon clicking the button, sets the value of the textarea to nothing. However, before this happens, the user gets an alert that confirms they want to clear and if the response to this is true, the function proceeds. For the submit button, we specified in the HTML that it submits the form that it is attached to. However, the submission made from the timer ending is a little more complicated. Once the minutes and the seconds reach 0, the timer then goes into the document labelled “entry” and submits that, achieving the same effect. As for the design of the timer, we first set the timer’s numeric values to 002 and 000, separated by a colon into minutes and seconds. We then assigned the variable m as the first part of that split and the variable s as the second part. When seconds reached 59, the minute value dropped by 1, like a real timer. Additionally, for the functionality of the seconds, if the value is less than 10, a zero is added before the number and if the value of seconds ever drops below 0, it reverts back to 59. One problem we ran into with the timer starting on input is that any additionally typing from the user starting the timer function again, accelerating the rate of the timer. To work around this, we removed the input event listener on the very first time that the user inputs into this form. One issue that we ran into with design on this page was managing the spacing of the buttons relative to the timer and the text field. Any solution that we tried didn’t quite match the alignment we were aiming for so we ended up hardcoding the spacing by entering in <pre> fields that entered empty spaces in between the buttons and the timer. The typewriter style entrance of the text “what’s on your mind” was done so that it reflects the journal entry theme and is pleasing to see upon loading the page. Other titles in our website also use this design. This was achieved by coding two animations, one for the cursor to glide across, and one for the text to appear, both of which moved at the same speed. 

Once the form with the journal entry is submitted, it sends a POST request to the route “/results”. The results page should be unique to each journal entry, so trying to access “/results” directly through GET will send the user back to the home page. When the POST request is sent, the Python program will run sentiment analysis on the journal entry. The sentiment analysis that we conducted was done through a library called text2emotion, specifically using their get-emotion function. In order to use this library, you must first perform “pip install text2emotion” in the terminal to download the package. The function get_emotion returns a dictionary where the keys are the emotion names “Angry”, “Fear”, “Happy”, “Sad”, and “Surprise” and the values are decimal values between 0 and 1. The values for the five emotions always add up to 1. The Python program then sets five variables equal to the emotion values of the journal entry. We used a simple loop to find the greatest emotion value and its corresponding emotion. Then, we used if statements to display different messages depending on which emotion had the greatest value. We then inserted the journal entry and its emotions into the database and then rendered the results template with the message and emotion values. You can see we commented out the code that we were trying to use to create a Spotify playlist and display that Spotify playlist on the results page.

The results.html template contains the message from the Python program and a doughnut chart displaying the analyzed emotions. We created the chart in JavaScript using chart.js. The data for the chart is sent using Jinja from the Python program in a dictionary with all the emotions and their corresponding values. We hand-picked colors for each emotion in the chart.

For the journals page, we used a design similar to the history page on CS50 Finance where we go through every SQL that corresponds to the user’s id and then prints the entry with the corresponding date that the entry was written, organized so that the newest entry appears at the top. Additionally, we added a delete button to each entry that submits the id of the corresponding journal entry through POST to the “/journals” route. When the form is submitted, the program runs an SQL command that deletes that particular row from the database and then reloads the journal page with the deleted entry now missing. 

For the vibes page, we aimed to have the user be able to track their emotional progress over time and used another JavaScript chart to display this information. Since the chart was a line graph, the emotion data had to be turned into lists where each list contained all the values for each emotion over time. For example, the “angry” list contained all the angry values for all the entries. We also created a “date” list so that users could see the date of each entry if they hovered over specific data points. We used an SQL command to gather all the emotion and date data for the user and then used a for loop to sort the emotion and date data into corresponding lists. Next, we used another SQL command to find the total number of entries to determine the width of the chart. If there were 10 or less entries, the chart’s width would be set to 600px. If there were more than 10 entries, then the chart’s width would increase by 60 for each entry to make sure the chart didn’t get too crowded. In the rendered html, we did a few things to make all this look nice. First, we set overflow-x to scroll and position to relative in the style for the chart to add the scrollbar for when the chart got too big. We made the background to the chart transparent. In the Javascript, we used Jinja again to set the labels to be the dates of each journal entry. We also sent the data using Jinja for each line in the chart (angry line, fear line, etc.). We used the same colors for the lines as the colors in the doughnut chart, except we had to decrease the opacity of the color that spanned below the lines. We also added some other options to make the chart appear nice. For example, we turned off the ticks for the x-axis and we set the y-axis to always go from 0 to 1. 

Finally, we have the about page. The about page is very simple and features some explanation of the site’s functionality as well as pictures of us, the programmers and is accessible with or without logging in. The photos also have links to our Twitter pages if you click on them.

